import 'dart:async';
import 'package:flutter/material.dart';
import '../data/models/models.dart';
import '../services/firebase_service.dart';

class AppProvider with ChangeNotifier {
  final FirebaseService _service = FirebaseService();
  
  List<Apartment> _apartments = [];
  List<Flat> _flats = [];
  List<User> _tenants = [];
  List<RentRecord> _rentRecords = [];
  List<PaymentRecord> _payments = [];

  StreamSubscription? _flatsSub;
  StreamSubscription? _tenantsSub;
  StreamSubscription? _rentSub;
  StreamSubscription? _paymentSub;

  List<Apartment> get apartments => _apartments;
  List<Flat> get flats => _flats;
  List<User> get tenants => _tenants;
  List<RentRecord> get rentRecords => _rentRecords;
  List<PaymentRecord> get payments => _payments;

  AppProvider() {
    _initData();
  }

  void _initData() {
    // Keep one dummy apartment for MVP as we haven't built Property Management UI yet
    _apartments = [
      Apartment(id: 'apt_1', ownerId: 'owner_1', name: 'Shanti Niwas', address: '123 Sky Lane, Mumbai'),
    ];

    // Listen to Streams
    _flatsSub = _service.getFlats().listen((data) {
      _flats = data;
      notifyListeners();
    });

    _tenantsSub = _service.getTenants().listen((data) {
      _tenants = data;
      notifyListeners();
    });

    _rentSub = _service.getRentRecords().listen((data) {
      _rentRecords = data;
      notifyListeners();
    });

    _paymentSub = _service.getPayments().listen((data) {
      _payments = data;
      notifyListeners();
    });
  }

  @override
  void dispose() {
    _flatsSub?.cancel();
    _tenantsSub?.cancel();
    _rentSub?.cancel();
    _paymentSub?.cancel();
    super.dispose();
  }

  // Apartment Methods (Placeholder)
  void addApartment(Apartment apt) {
    _apartments.add(apt);
    notifyListeners();
  }

  // Flat Methods
  Future<void> addFlat(Flat flat) async {
    await _service.addFlat(flat);
  }

  Future<void> updateFlat(Flat flat) async {
     await _service.updateFlat(flat);
  }

  // Tenant Methods
  Future<void> addTenant(User tenant, String flatId) async {
    // 1. Add User to 'users' collection
    await _service.addTenant(tenant);
    
    // 2. Update Flat to occupied
    final flatIndex = _flats.indexWhere((f) => f.id == flatId);
    if (flatIndex != -1) {
      final updatedFlat = Flat(
        id: _flats[flatIndex].id,
        apartmentId: _flats[flatIndex].apartmentId,
        flatNumber: _flats[flatIndex].flatNumber,
        floor: _flats[flatIndex].floor,
        monthlyRent: _flats[flatIndex].monthlyRent,
        isOccupied: true,
        currentTenantId: tenant.id,
      );
      await _service.updateFlat(updatedFlat);
    }
  }

  // Rent Methods
  Future<void> generateMonthlyRent(String flatId, String month, double amount, DateTime dueDate) async {
    final flat = _flats.firstWhere((f) => f.id == flatId, orElse: () => Flat(id: '', apartmentId: '', flatNumber: '', floor: 0, monthlyRent: 0));
    if (flat.id.isEmpty || !flat.isOccupied || flat.currentTenantId == null) return;

    // Check for duplicates in local list (optimistic check)
    final exists = _rentRecords.any((r) => r.flatId == flatId && r.month == month);
    if (exists) return;

    final now = DateTime.now();
    final newRent = RentRecord(
      id: '', // Auto-generated by Firebase
      flatId: flatId,
      tenantId: flat.currentTenantId!,
      month: month,
      baseRent: amount,
      generatedDate: now,
      dueDate: dueDate,
      status: RentStatus.pending,
      flag: RentFlag.yellow,
    );
    
    await _service.addRentRecord(newRent);
  }

  // Payment Methods
  Future<void> submitPayment(PaymentRecord payment) async {
    await _service.submitPayment(payment);
  }

  Future<void> approvePayment(String paymentId) async {
    // 1. Update Payment Status
    await _service.updatePaymentStatus(paymentId, PaymentStatus.approved);

    // 2. Update Rent Record (Client-side calculation logic migrated to server typically, but handling here for immediate sync)
    final payment = _payments.firstWhere((p) => p.id == paymentId);
    final rentIndex = _rentRecords.indexWhere((r) => r.id == payment.rentId);
    
    if (rentIndex != -1) {
      final rent = _rentRecords[rentIndex];
      final newAmountPaid = rent.amountPaid + payment.amount;
      final isFullyPaid = newAmountPaid >= rent.totalDue;
      
      final updatedRent = RentRecord(
        id: rent.id,
        flatId: rent.flatId,
        tenantId: rent.tenantId,
        month: rent.month,
        baseRent: rent.baseRent,
        electricityCharges: rent.electricityCharges,
        penaltyApplied: rent.penaltyApplied,
        amountPaid: newAmountPaid,
        generatedDate: rent.generatedDate,
        dueDate: rent.dueDate,
        status: isFullyPaid ? RentStatus.paid : (newAmountPaid > 0 ? RentStatus.partial : rent.status),
        flag: isFullyPaid ? RentFlag.green : rent.flag,
      );
      
      await _service.updateRentRecord(updatedRent);
    }
  }

  Future<void> rejectPayment(String paymentId) async {
    await _service.updatePaymentStatus(paymentId, PaymentStatus.rejected);
  }
}
